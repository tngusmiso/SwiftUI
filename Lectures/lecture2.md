
# Lecture 2 :: MVVM and the Swift Type System

[![Stanford SwiftUI 2020](http://img.youtube.com/vi/4GjXq2Sr55Q/0.jpg)](https://www.youtube.com/watch?v=4GjXq2Sr55Q)

## 🍎 MVVM
* SwiftUI에서 사용하는 디자인 패턴
* 과거 UIKit에서는 MVC를 많이 사용했다.

![image1](./img2/image1.png)

### Model
* UI 독립적 : SwiftUI를 import 하지 않는다.
* 데이터와 로직을 캡슐화한다.

### View
* 모델을 반영 : View 자체에서는 상태를 가지지 않으며, 모델의 상태를 반영한다.
* 데이터의 흐름 : (모델 -> 뷰) 뷰는 모델을 읽어오기만 하고, 변경할 수 없다.
* 선언적 : 간결한 코드로 선언되어 있을 뿐!
* 반응적 : 모델이 변경될 때 마다 반응하여 뷰가 자동으로 갱신된다.

### ViewModel
* 뷰를 모델에 바인딩 하는 역할
* 모델에 대한 모든것을 알고 있다. 뷰에 대해서는 알지 못한다.
* **모델의 변화를 알아챔** -> **모델을 뷰의 언어로 해석** -> **뷰 갱신(직접 대화 X)**
    - 뷰모델은 모델을 알고 있다. 모델의 변경사항이 발생하면 뷰모델이 알아챈다.
    - 뷰가 사용하기 좋도록 모델을 해석한다. 이 프로젝트에서 Model은 단순히 구조체(struct)이지만, 데이터베이스나 Http통신의 요청 결과값이 될 수도 있다. 복잡한 모델을 단순화하여 뷰가 필요한 정보만 뽑아내는 것이다.
    - 뷰모델을 뷰를 모른다. 뷰는 뷰모델을 구독하여, 변경사항이 있을 때 마다 뷰모델에게 물어봐서 자신을 변경한다.
* **Intent 처리** -> **모델 변경**
    - 뷰에서 이벤트가 발생하면 뷰모델의 Intent 함수를 호출한다.
    - 모델을 의도대로 변경한다. 모델이 struct라면 프로퍼티를 변경하는 것일 수도 있고, 데이터베이스라면 SQL문을 호출하는 것일수도 있다. 
* 이러한 양 방향의 흐름은 끊임없이 반복된다. (M->VM->V -> V->VM->M)
